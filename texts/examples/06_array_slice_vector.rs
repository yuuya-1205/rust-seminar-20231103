fn main() {
    // 配列型
    //
    // [i32; 4]の配列型。i32型が4つの意味。
    let array1 = [0, 1, 2, 3];

    // これは[f64; 3]の配列型
    let array2 = [0.0, 1.0, 2.0];

    // スライス
    //
    // 配列の一部を参照するとスライスになる。
    // 後で登場する&strもスライス

    // これは&[i32]のスライス
    // 0..2はレンジ（range）で「0から2未満まで」の意味
    // 0..=2とすれば終点も含む
    let array1_slice = &array1[0..2];

    // ベクタ（Vec<T>）
    //
    // 空のベクタを作る。要素を追加したりするときはmutを忘れずに
    let mut v1 = Vec::new();
    v1.push(1);

    // vec!マクロで初期化することもできる
    let v2 = vec![1, 2, 3];
    let v3: Vec<i32> = vec![];

    // [usize]で要素にアクセスできる
    assert_eq!(v2[0], 1);
    assert_eq!(v2[1], 2);
    assert_eq!(v2[2], 3);

    // 要素に順番にアクセスする
    // for式（所有権を奪うパターン）
    for e in v2 {
        // このときeはi32型
        println!("{}", e);
    }
    // for式で所有権が奪われているのでコンパイルエラー
    // let x = v2;

    let v4 = vec![true, false];
    for e in &v4 {
        // このときeは&bool(参照になっていることに注意)
        println!("{}", e);
    }

    // for式で所有権が奪われていないのでコンパイルできる
    let y = v4;
}
