# ライフタイム

## TL;DR
- 参照が有効な期間をライフタイムという
- ライフタイムの主な目的は、ダングリング参照を回避すること
- 型推論のようにライフタイムも推論してくれるが、ときおりプログラマがライフタイムを指定する必要がある
- 型パズルならぬライフタイムパズルに苦しめられることもしばしば


## ダングリング参照（ダングリングポインタ）
[ダングリングポインタとは｜dangling pointerの危険性と回避 | MaryCore](https://marycore.jp/coding/dangling-pointer/#%E3%83%80%E3%83%B3%E3%82%B0%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%AE%E4%BE%8B) より引用

解放済みのオブジェクトポインタはダングリングポインタ

```c
char *p = malloc(1); // メモリ確保
free(p);             // メモリ解放

p;        // ポインタ変数`p`は既にダングリングポインタ
*p = 'c'; // ダングリングポインタへのアクセス（危険）
```

また、寿命を迎えたオブジェクトを参照し続けているポインタも、ダングリングポインタ

```c
char *p = NULL;
{
  // 自動変数`c`の生存期間はスコープ内のみ
  char c = 'c';
  p = &c; // ローカル変数の参照を保持
}
          // ローカル変数`c`の寿命は既に尽きている
p;        // よってポインタpはダングリングポインタ
printf("%c", *p); // 不定な動作を引き起こすため危険
```

----
C言語ではダングリングポインタを含むコードをコンパイルして実行できてしまう。

Rustで似たようなコードを書いてみる。

```rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }


    // 変数xの値を出力しようと試みる
    println!("r: {}", r);
}
```

外側のスコープで初期値なしの`r`という変数を宣言し、内側のスコープで初期値5の`x`という変数を宣言しています。
内側のスコープ内で、`r`の値を`x`への参照にセットしようとしています。それから内側のスコープが終わり、
`r`の値を出力しようとしています。`r`が参照している値が使おうとする前にスコープを抜けるので、
このコードはコンパイルできません。こちらがエラーメッセージです:

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
（エラー[E0597]: `x`の生存期間が短すぎます）
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
   |                   (借用された値の生存期間が短すぎます)
8  |         }
   |         - `x` dropped here while still borrowed
   |          (`x`は借用されている間にここでドロップされました)
9  | 
10 |         println!("r: {}", r);
   |                           - borrow later used here
   |                            (その後、借用はここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
```

変数`x`の「生存期間が短すぎます」。原因は、内側のスコープが7行目で終わった時点で`x`がスコープを抜けるからです。
ですが、`r`はまだ、外側のスコープに対して有効です; スコープが大きいので、「長生きする」と言います。
Rustで、このコードが動くことを許可していたら、`r`は`x`がスコープを抜けた時に解放されるメモリを参照していることになり、
`r`で行おうとするいかなることもちゃんと動作しないでしょう。では、どうやってコンパイラはこのコードが無効であると決定しているのでしょうか？
それは、借用チェッカーを使用しているのです。

## 借用精査機（borrow checker）

ここで、`r`のライフタイムは`'a`、`x`のライフタイムは`'b`で注釈しました。ご覧の通り、
内側の`'b`ブロックの方が、外側の`'a`ライフタイムブロックよりはるかに小さいです。
コンパイル時に、コンパイラは2つのライフタイムのサイズを比較し、`r`は`'a`のライフタイムだけれども、
`'b`のライフタイムのメモリを参照していると確認します。`'b`は`'a`よりも短いので、プログラムは拒否されます:
参照の対象が参照ほど長生きしないのです。

![](../medias/lifetime_ng.jpg)

コードを修正したので、ダングリング参照はなくなり、エラーなくコンパイルできます。

```rust
fn main() {
    {
        let x = 5;

        let r = &x;

        println!("r: {}", r);
    }
}

```

![](../medias/lifetime_ok.jpg)

ここで`x`のライフタイムは`'b`になり、今回の場合`'a`よりも大きいです。つまり、
コンパイラは`x`が有効な間、`r`の参照も常に有効になることを把握しているので、`r`は`x`を参照できます。

## 関数シグニチャにおけるライフタイム注釈

<!-- TODO: -->